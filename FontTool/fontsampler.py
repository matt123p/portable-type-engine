from PIL import Image, ImageDraw, ImageFont, ImageChops
from fontTools.ttLib import TTFont
import sys
import argparse

class Glyph:
    def __init__(self, c, code, width, height, xoffset, yoffset, ptr, xadvance):
        self.c = c
        self.code = code
        self.width = width
        self.height = height
        self.xoffset = xoffset
        self.yoffset = yoffset
        self.ptr = ptr
        self.xadvance = xadvance

class Kern:
    def __init__(self, first, second, amount):
        self.first = first
        self.second = second
        self.amount = amount

class FontSampler:
    def __init__(self, char_selection, encoding):
        self.m_charSelection = []
        self.m_glyphs = {}
        self.m_data = []
        self.m_kerns = []
        self.m_uncompressed_size = 0
        self.encoding = encoding

        if char_selection is None:
            self.m_charSelection.append((32, 255))
        else:
            self.m_charSelection.extend(char_selection)

    def convertFont(self, font, tt_font, filename):
        # Process each character in the selection
        for start, end in self.m_charSelection:
            for i in range(start, end + 1):
                # Skip out special character of ISO8859
                if i in (127, 240, 173):
                    continue
                self.convertGlyph(font, self.char_to_unicode(i))

        # Calculate kerning for each pair of glyphs
        self.calcAllKerns(tt_font)

        fontName = font.getname()[0].replace(" ", "_")
        with open(filename, 'w') as fout:
            fout.write("// Output generated by Portable Type Engine's Font Tool\n")
            fout.write("// FONT: " + font.getname()[0] + "\n")
            fout.write("// Font Pixel Height Sampled: " + str(font.size) + "\n")
            fout.write("// Font encoding: " + self.encoding + "\n\n")
            # Calculate total data size: image data + glyph data + kern data
            total_bytes = len(self.m_data) + (28 * len(self.m_glyphs)) + (12 * len(self.m_kerns))
            fout.write("// Font data size: " + str(len(self.m_data) + (28 * len(self.m_glyphs))) + " bytes\n")
            fout.write("// Font kerning table: " + str(12 * len(self.m_kerns)) + " bytes\n")
            fout.write("// Total font data size: " + str(total_bytes) + " bytes (" + format(total_bytes/1024.0,".1f") + "Kb)\n\n")

            fout.write("#include \"pte.h\"\n\n")

            # Output glyphs
            fout.write("static const pte_glyph " + fontName + "_glyphs[" + str(len(self.m_glyphs)) + "] = {\n")
            for code, g in self.m_glyphs.items():
                fout.write(" { " + str(code) + "," + str(g.width) + "," + str(g.height) + ","
                        + str(g.xoffset) + "," + str(g.yoffset) + "," + str(g.xadvance) + ","
                        + str(g.ptr) + " },\n")
            fout.write("};\n\n")

            # Output data array
            fout.write("static const unsigned char " + fontName + "_data[" + str(len(self.m_data)) + "] = {")
            count = 0
            for i, val in enumerate(self.m_data):
                if count % 50 == 0:
                    fout.write("\n ")
                fout.write(str(val))
                if i != len(self.m_data) - 1:
                    fout.write(",")
                count += 1
            fout.write("\n};\n\n")

            # Output kerning data if available
            if self.m_kerns:
                fout.write("static const pte_kern " + fontName + "_kerns[" + str(len(self.m_kerns)) + "] = {\n")
                for k in self.m_kerns:
                    fout.write(" { " + str(k.first) + "," + str(k.second) + "," + str(self.scaleKern(k.amount, font, tt_font)) + " },\n")
                fout.write("};\n\n")

            # Output font structure
            fout.write("static pte_base_font f =\n")
            fout.write(" { " + str(font.size) + ", "
                    + fontName + "_data, "
                    + str(len(self.m_glyphs)) + ","
                    + fontName + "_glyphs, ")
            if self.m_kerns:
                fout.write(str(len(self.m_kerns)) + ","
                        + fontName + "_kerns, ")
            else:
                fout.write("0,0,")

            # For line spacing, we use font.getsize on a capital letter
            ascent, descent = font.getmetrics()
            lineSpacing = ascent + descent
            # lineSpacing = self.get_text_size(font, "M")[1]
            fout.write(str(lineSpacing) + ", " + str(font.size) + " };\n\n")
            fout.write("pte_base_font *get_" + fontName + str(font.size) + "()\n")
            fout.write("{\n    return &f;\n}\n")

    def output_pixel(self, run_of_on, pixels_so_far, pixel):
        if run_of_on:
            pixel |= (pixels_so_far << 4)
        else:
            pixel |= pixels_so_far
            self.m_data.append(pixel)
            pixel = 0
        pixels_so_far = 0
        run_of_on = not run_of_on
        return run_of_on, pixels_so_far, pixel

    def val(self, c):
        return ord(c)

    def convertGlyph(self, font, c):
        # Get approximate text size using Pillow's font measurement
        w, h = self.get_text_size(font, c)
        img_width = w * 2 if w > 0 else 1
        img_height = h * 4 if h > 0 else 1

        # Create a white background image and draw the character in black.
        image = Image.new("RGB", (img_width, img_height), "white")
        draw = ImageDraw.Draw(image)
        baseline = h * 3
        draw.text((0, baseline), c, fill="black", font=font, anchor="ls")

        # Determine the bounding box of non-white (black) pixels.
        # Invert image colors so that text becomes non-zero then use getbbox().
        inv = ImageChops.invert(image)
        bbox = inv.getbbox()
        if bbox is None:
            bbox = (0, 0, 0, 0)

        left, top, right, bottom = bbox
        width = (right - left) 
        height = (bottom - top)
        xoffset = left
        yoffset = baseline - top
        xadvance = self.get_text_size(font, c)[0]
        code = self.val(c)
        ptr = len(self.m_data)
        g = Glyph(c, code, width, height, xoffset, yoffset, ptr, xadvance)
        self.m_glyphs[code] = g

        self.m_uncompressed_size = ((width + 7) // 8) * height

        pixel = 0
        run_of_on = False
        pixels_so_far = 0

        # Process pixels in the bounding box.
        for y in range(top, bottom):
            for x in range(left, right):
                last_pixel = (x == right - 1 and y == bottom - 1)
                # Check if pixel is more than 50% black
                # Note: We are using RGB mode so black is (0, 0, 0)
                t = image.getpixel((x, y))
                on = t[0] < 128
                if run_of_on != on:
                    run_of_on, pixels_so_far, pixel = self.output_pixel(run_of_on, pixels_so_far, pixel)
                pixels_so_far += 1
                if pixels_so_far == 15:
                    run_of_on, pixels_so_far, pixel = self.output_pixel(run_of_on, pixels_so_far, pixel)
                if last_pixel and pixels_so_far != 0:
                    run_of_on, pixels_so_far, pixel = self.output_pixel(run_of_on, pixels_so_far, pixel)
                if last_pixel and run_of_on:
                    run_of_on, pixels_so_far, pixel = self.output_pixel(run_of_on, pixels_so_far, pixel)

    def calcAllKerns(self, tt_font):
        # Create a reverse mapping (glyph name -> code) for characters in charSelection
        cmap = tt_font.getBestCmap()
        rev_cmap = {}
        for code, glyph_name in cmap.items():
            for start, end in self.m_charSelection:
                if start <= self.unicode_to_char(code) <= end:
                    rev_cmap[glyph_name] = code
                    break

        # Clear existing kerning data
        self.m_kerns = []

        # Process legacy 'kern' table if available.
        if 'kern' in tt_font:
            for subtable in tt_font['kern'].kernTables:
                for (glyph_name_a, glyph_name_b), amount in subtable.kernTable.items():
                    if amount == 0:
                        continue
                    if glyph_name_a in rev_cmap and glyph_name_b in rev_cmap:
                        k = Kern(rev_cmap[glyph_name_a], rev_cmap[glyph_name_b], amount)
                        self.m_kerns.append(k)
        # Otherwise, try processing the GPOS table for kerning.
        elif 'GPOS' in tt_font:
            gpos_table = tt_font['GPOS'].table
            if hasattr(gpos_table, 'LookupList'):
                for lookup in gpos_table.LookupList.Lookup:
                    if lookup.LookupType != 2:
                        continue
                    for subtable in lookup.SubTable:
                        if subtable.Format == 1:
                            # Format 1: Glyph-specific pair sets.
                            coverage = subtable.Coverage.glyphs
                            for i, pairSet in enumerate(subtable.PairSet):
                                firstName = coverage[i]
                                if firstName not in rev_cmap:
                                    continue
                                for record in pairSet.PairValueRecord:
                                    secondName = record.SecondGlyph
                                    if secondName in rev_cmap:
                                        value1 = (record.Value1.XAdvance
                                            if record.Value1 and hasattr(record.Value1, "XAdvance")
                                            else 0)
                                        if value1 != 0:
                                            k = Kern(rev_cmap[firstName], rev_cmap[secondName], value1)
                                            self.m_kerns.append(k)
                        elif subtable.Format == 2:
                            # Format 2: Class-based kerning (not implemented)
                            pass            
    def scaleKern(self, kern_amount, font, tt_font):
        # Get the unitsPerEm from the font's head table
        units_per_em = tt_font['head'].unitsPerEm
        # Calculate the scaling factor from design units to pixels
        scale = font.size / units_per_em
        # Return the kern value scaled to pixels (rounded to nearest int)
        return int(round(kern_amount * scale))                    
                        
    def get_text_size(self, font, text):
        bbox = font.getbbox(text)
        if bbox:
            return (bbox[2] - bbox[0], bbox[3] - bbox[1])
        return (0, 0)
    
    def char_to_unicode(self, char_code):
        try:
            return bytes([char_code]).decode(self.encoding)
        except (ValueError, UnicodeDecodeError):
            return ''
        
    def unicode_to_char(self, unicode_char):
        try:
            c = chr(unicode_char).encode(self.encoding)
            return ord(c)
        except (ValueError, UnicodeEncodeError):
            return 0
    
# New helper function to interpret the shorthand charset string.
def parse_charset(shorthand):
    ranges = []
    encoding = "iso-8859-1"

    for ch in shorthand:
        if ch == 'n':
            ranges.append((48, 57))
        elif ch == 'a':
            ranges.append((97, 122))
        elif ch == 'A':
            ranges.append((65, 90))
        elif ch.isdigit():
            # For ISO8859 sets, you can later modify to handle different tables.
            # For now all digit options map to the same printable range.
            iso_number = int(ch)
            encoding = f"iso-8859-{iso_number}"
        elif ch == '.':
            # Add common punctuation ranges.
            ranges.extend([(33, 47), (58, 64), (91, 96), (123, 126)])

    if not ranges:
        # Default to ISO8859-1 printable characters
        ranges = [(32, 126), (160, 255)]
            
    return ranges, encoding


if __name__ == '__main__':

    parser = argparse.ArgumentParser(
        description="Convert font files into C arrays for Portable Type Engine."
    )
    parser.add_argument("font_file", help="Path to the font file.")
    parser.add_argument("output_file", nargs="?", default="output_font.c",
                        help="Output C file name (default: output_font.c)")
    parser.add_argument("--charset", type=str, default="",
        help=("Specify character sets to convert using shorthand options:\n"
            " n: numbers (0-9)\n"
            " a: lowercase letters (a-z)\n"
            " A: uppercase letters (A-Z)\n"
            " 1,2,3...: ISO8859-X (printable characters from 32 to 255)\n"
            " .: punctuation (33-47,58-64,91-96,123-126)\n"
            " Example: 'aAn' converts lowercase, uppercase and numbers"))

    if len(sys.argv) < 2 or sys.argv[1] in ("-h", "--help"):
        print("Usage: python fontsampler.py <font-file-path> [output file-name]")
        sys.exit(1)

    args = parser.parse_args()

    font_file = sys.argv[1]
    output_file = sys.argv[2] if len(sys.argv) > 2 else "output_font.c"
    char_ranges, encoding = parse_charset(args.charset)

    try:
        sample_font = ImageFont.truetype(font_file, 128)
    except IOError:
        print("Unable to load font. Please check the font file path.")
        sys.exit(1)

    # Also load the font via fontTools.
    try:
        from fontTools.ttLib import TTFont
        tt_font = TTFont(font_file)
    except Exception as e:
        print("Unable to load the font via fontTools:", e)
        sys.exit(1)

    sampler = FontSampler(char_selection=char_ranges, encoding=encoding)
    sampler.convertFont(sample_font, tt_font, output_file)
    sys.exit(0)
