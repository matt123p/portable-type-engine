/*
    FontTool for the Portable Font Engine.
    Copyright (C) 2015  Matt Pyne

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "fontsampler.h"
#include <QImage>
#include <QFontMetrics>
#include <QPainter>
#include <ostream>
#include <fstream>

FontSampler::FontSampler()
{

}

FontSampler::~FontSampler()
{

}

void FontSampler::convertFont( QFont font, QString filename, QString encoding )
{
    m_encoding = QTextCodec::codecForName( encoding.toLatin1() );
    m_encoder = m_encoding->makeEncoder();
    m_decoder = m_encoding->makeDecoder();

    m_uncompressed_size = 0;

    if (m_charSelection.size() == 0)
    {
        m_charSelection.push_back( intPair(32,255) );
    }

    for (auto p = m_charSelection.begin(); p != m_charSelection.end(); ++ p)
    {
        for (int i = p->first; i <= p->second; ++ i)
        {
            // Skip out special character of ISO8859
            if (i == 127 || i == 240 || i == 173)
            {
                continue;
            }
            char b = i;
            QString c( m_decoder->toUnicode(&b,1) );
            convertGlyph( font, c.at(0) );
        }
    }

    for (auto a = m_glyphs.begin(); a != m_glyphs.end(); ++ a)
    {
        for (auto b = m_glyphs.begin(); b != m_glyphs.end(); ++ b)
        {
            calcKern(font, a->second.c, b->second.c);
        }
    }

    std::ofstream fout;
    fout.open( filename.toLocal8Bit() );

    std::string fontName = font.family().toStdString();
    std::replace( fontName.begin(), fontName.end(), ' ', '_');

    //
    // Output the header
    //
    fout << "// Output generated by Portable Type Engine's Font Tool" << std::endl;
    fout << "// FONT: " << font.family().toStdString() << std::endl;
    fout << "// Size: " << font.pixelSize() << std::endl;
    fout << std::endl;

    fout << std::endl;
    fout << "#include \"pte.h\"";
    fout << std::endl;


    //
    // Output the glyphs
    //
    fout << "static const pte_glyph " << fontName << "_glyphs[" << m_glyphs.size() << "] = {" << std::endl;
    for (auto i = m_glyphs.begin(); i != m_glyphs.end(); ++ i)
    {
        fout << " { "
             << i->first << "," << i->second.width  << "," << i->second.height << ","
             << i->second.xoffset << "," << i->second.yoffset << "," << i->second.xadvance << ","
             << i->second.ptr
             << " }," << std::endl;
    }
    fout << "};" << std::endl;
    fout << std::endl;

    //
    // Output the data
    //
    fout << "static const unsigned char " << fontName << "_data[" << m_data.size() << "] = {";
    int count = 0;
    for (auto i = m_data.begin(); i != m_data.end(); ++ i)
    {
        if ((count % 50) == 0)
        {
            fout << std::endl << " ";
        }
        fout << static_cast<int>(*i);
        if (count != m_data.size() - 1)
        {
            fout << ",";
        }

        ++ count;
    }
    fout << "};" << std::endl;
    fout << std::endl;

    //
    // Output the kerning data
    //
    if (m_kerns.size() > 0)
    {
        fout << "static const pte_kern " << fontName << "_kerns[" << m_kerns.size() << "] = {" << std::endl;
        for (auto i = m_kerns.begin(); i != m_kerns.end(); ++ i)
        {
            fout << " { "
                 << i->first << "," << i->second  << "," << i->amount
                 << " }," << std::endl;
        }
        fout << "};" << std::endl;
        fout << std::endl;
    }

    //
    // Output the font structure
    //
    fout << "static pte_base_font f =" << std::endl;
    fout << " {"
         << font.pixelSize() << ", "
         << fontName << "_data, "
         << m_glyphs.size() << ","
         << fontName << "_glyphs, ";

    if (m_kerns.size() > 0)
    {
        // Add the kerning table
        fout << m_kerns.size() << ","
             << fontName << "_kerns, ";
    }
    else
    {
        // No kerning information
        fout << "0,"
             << "0,";
    }

    QFontMetrics metrics(font);
    fout << metrics.lineSpacing() << ", "
         << font.pixelSize() - metrics.descent()
         << " };" << std::endl;
    fout << std::endl;

    //
    // The accessor function
    //
    fout << "pte_base_font *get_" << fontName << font.pixelSize() << "()" << std::endl;
    fout << "{" << std::endl;
    fout << "    return &f;" << std::endl;
    fout << "}" << std::endl;
    fout << std::endl;



}

void FontSampler::output_pixel( bool &run_of_on, int &pixels_so_far, unsigned char &pixel)
{
    if (run_of_on)
    {
        // Number of "on" pixels
        pixel |= (pixels_so_far << 4);
    }
    else
    {
        // Number of "off" pixels
        pixel |= pixels_so_far;
    }

    if (!run_of_on)
    {
        m_data.push_back(pixel);
        pixel = 0;
    }

    pixels_so_far = 0;
    run_of_on = !run_of_on;
}

int FontSampler::val( QChar c )
{
    QString s(c);
    return (unsigned char)(m_encoder->fromUnicode(s).at(0));
}


void FontSampler::convertGlyph(QFont font, QChar c)
{
    // Get the font metrics
    QFontMetrics metrics( font );
    QRect r = metrics.boundingRect( c );

    // Image to draw the image in to
    QImage img( r.width()*2, r.height()*4, QImage::Format_RGB32 );

    // Draw the image
    {
        QPainter painter( &img );
        QString s;
        s += c;

        painter.setPen(Qt::black);
        painter.fillRect( 0,0,img.width(),img.height(), QBrush(Qt::white) );
        painter.setFont(font);
        painter.drawText(0,r.height()*3,s);
    }

#if 0
    if ( (unsigned char)c.toLatin1() == 176 )
    {
        img.save( "/Users/matt/Documents/riverbank/Products/out.png");
    }
#endif

    // Determine the actual bounding rect
    int top = 0;
    int bottom = 0;
    int left = 0;
    int right = 0;
    bool first = true;

    for (int y = 0; y < img.height(); ++ y)
    {
        for (int x = 0; x < img.width(); ++ x)
        {
            auto p = img.pixel(x,y);
            if ((p&0xff) == 0)
            {
                if (first)
                {
                    top = y;
                    bottom = y;
                    left = x;
                    right = x;
                    first = false;

                }
                else
                {
                    top = std::min(y,top);
                    bottom = std::max(y,bottom);
                    left = std::min(x,left);
                    right = std::max(x,right);
                }
            }
        }
    }

    // Create the glyph object
    glyph g;
    g.c = c;
    g.code = val(c);
    g.width = (right-left)+1;
    g.height = (bottom-top)+1;
    g.xoffset = left;
    g.yoffset = r.height()*3 - top;
    g.ptr = m_data.size();
    g.xadvance = metrics.leftBearing(c) + r.width() + metrics.rightBearing(c);
    m_glyphs[ g.code ] = g;

    m_uncompressed_size = ((g.width+7)/8) *g.height;

    // Now generate the image data
    unsigned char pixel = 0;
    bool run_of_on = false;
    int pixels_so_far = 0;

    for (int y = top; y <= bottom; ++ y)
    {
        for (int x = left; x <= right; ++ x)
        {
            bool last_pixel = (x == right) && (y == bottom);
            int on = (img.pixel(x,y) & 0xff) == 0;


            // Is this a change in run?
            if (run_of_on != on)
            {
                output_pixel( run_of_on, pixels_so_far, pixel);
            }
            ++ pixels_so_far;

            // Have we reached the limit of outputting pixels
            if (pixels_so_far == 15)
            {
                output_pixel( run_of_on, pixels_so_far, pixel);
            }

            // Is this the last one?
            if (last_pixel && pixels_so_far != 0)
            {
                output_pixel( run_of_on, pixels_so_far, pixel);
            }
            if (last_pixel && run_of_on)
            {
                output_pixel( run_of_on, pixels_so_far, pixel);
            }
        }
    }
}

void FontSampler::calcKern( QFont font, QChar a, QChar b )
{
    if (a == b)
    {
        return;
    }

    QFontMetrics metrics( font );

    QString s = a;
    s += b;

    int a_width = m_glyphs[ val(a) ].width;
    int b_width = m_glyphs[ val(b) ].width;
    QRect s_rect = metrics.boundingRect( s );

    int calcWidth = a_width + metrics.rightBearing(a)
            + metrics.leftBearing(b) + b_width;

    int amount = calcWidth - s_rect.width();
    if (amount > 1)
    {
        kern k;
        k.first = val(a);
        k.second = val(b);
        k.amount = -amount;
        m_kerns.push_back(k);
    }
}
